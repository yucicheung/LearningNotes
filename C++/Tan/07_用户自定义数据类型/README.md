# 自定义数据类型
**3-7章为面向过程的章节，这是其中最后一章**
- 用户自定义类型(user-defined type,UDT)
  - 结构体`struct`
	- 用`string`会比使用`char[]`好得多。
  - 共用体`union`
  - 枚举类型`enumeration`
  - 类`class`
- 类型别名`typedef`

## 结构体类型
- 使用结构体类型的必要性
  - 数组是用户的自定义类型，但是它的要求是其中各元素是属于同一类型，并且空间总是连续的。而我们有时需要将不同类型的数据组合成一个有机的整体，并且可能需要利用空间上不连续的内存单元。

- 结构体(结构体类型名一般首字母大写，如`Student`)
  - 在一个组合项中包含若干个类型不同(当然也可以相同)的数据项，C/C++中允许定义这种数据类型，称为结构体。
  - 相当于其他数据中的“记录”(record)，比如SQL。
  - **结构体声明的是一种类型**，用户的自定义类型。这种类型稍后可以像`int`等基本类型一样用于定义变量。
  - 结构体中的**每一个成员都是结构体中的一个域`field`**，成员表又称为域表。
  - C和C++的差异：
	- C语言中只允许结构体成员是数据;
	- **C++中对此加以扩充，成员可以是数据(即数据成员)，又可以包括函数(即函数成员)**。
  - 结构体声明的基本形式如下
```c++
//结构体声明基本形式
struct 结构体类型名
{成员表};

//结构体声明示例
//向编译系统声明一种名为`Student`的类型及其结构
struct Student
{int num;
char name[20];
char sex;
int age;
float score;
char addr[30];
};
//这和SQL中的`CREATE TABLE`过程很类似
```

- **定义结构体类型变量**的方法(C中定义必须有`struct`关键字，C++中做了简化，可以省去关键字`struct`。
  1. 先声明结构体类型再定义变量。
	- **提倡!!**将声明和定义分开，便于不同的函数甚至不同的文件都能使用声明的结构体类型。**若程序规模大，往往将若干个结构体的声明集中放到一个头文件中，当源文件需要用到该结构体类型时，用`#include`将文件包含到本文件中**，便于装配、修改和使用。
  2. 在声明类型同时定义变量
```c++
\\先声明再定义
struct Student
{
int num;
char name[20];
};
Student stu1,stu2;
\\声明同时定义
struct Student
{
int num;
char name[20];
}stu1,stu2;
```

- 关于结构体所占用字节的说明
  - 实际上，在分配存储单元时，是以字节(word)为单位时，一个字一般包括4个字节，所以一般分配的内存长度总是4个字节的整数。
  - 每个结构体类型变量的字节数是连续的。

- 成员也可以是一个结构体变量
```c++
//声明一个结构体类型
struct Date
{int month;
int day;
int year;
};
//在另一个结构体类型中用上述类型定义一个成员
struct Student
{
int num;
char name[20];
char sex;
Date birthday;
};
```

- 结构体变量的初始化(**要用字符串时采用`string`型变量更好**)。
  - 初始化总是在定义结构体类型变量时指定。
  - 初始化在定义结构体类型变量之后实现。
```c++
//结构体变量初始化基本形式
stu1={10002,"Zhang Xin",'M',19,90.5,"Shanghai"};
```

- **引用**结构体变量
  - 可以将一个结构体变量的值直接赋给另一个具有相同结构的结构体变量;`stu1=stu2;`
  - 可以引用一个结构体变量中的一个成员的值。
	- 基本形式：`结构体变量名.成员名`;
	- `student1.num=10010;`

- 结构体数组
  - 每个数组元素都是一个结构体类型变量,它们都分别包括每个成员项。

- 指向结构体变量的指针
  - 一个**结构体变量的指针就是该变量占据的内存段的起始地址**，指针变量也可以用来指向结构体数组中的元素。
  - 用结构体**指针变量引用成员**的形式，与`结构体变量.成员名`方式效果一致。
	1. `(*p).num`
    2. `p->num`，其中`->`是**指向运算符**
  - 注意
	- 在用指针变量实现成员引用时，`(*p).num`其中的**圆括号不能省略**，因为`.`优先级高于`*`，无括号会先和`.`结合，则整个表达式就成为一个元素的指针。

### 用结构体变量构成链表
- **单向链表**介绍
  - 链表有一个头指针`head`，存放着指向链表中的第一个元素;
  - 链表中每一个元素称为“结点”`node`：每个结点分别包含两部分，一部分是用户要用的实际数据，另一部分是下一个结点的地址。
  - 链表中的最后一个元素是"表尾" ，不再指向其他元素，它的地址是`NULL`(空地址)，链表到此结束。
- 链表在内存中的存储单元是不连续的。这也是它区别于数组的一个重要特点，以及是链表的优势之一。
```c++
//链表示例
struct Student
{int num;
float score;
Student *next;//指向下一个结构体类型变量，在指针变量赋值前当然结构体类型变量会先被定义
};
```
- **静态链表**：所有结点都是在程序中定义(**存储在栈中**)的，不是临时开辟的，也不能用完后释放。可以通过`next`指针访问，也可以通过结构体变量名访问。
- **动态链表**：各结点是可以随时插入和删除的，因为结点没有事前通过变量名开辟，只能在知道头指针head的情况下，一直用next指针访问。
  - 动态链表的建立需要以下的`new`和`delete`**运算符**。
### 结构体类型数据作为函数参数
- 将结构体变量数据传递给函数的方法
  - 用结构体变量名做参数。形参“值传递“方式，时间和空间开销都很大。
  - 用结构体指针做实参，将结构体变量的指针传递给函数。效率高但不直观。
  - 用结构体的引用做函数形参，它就成为实参(结构体变量)的别名。直观且效率高。**因此引用就是可以提高效率并且保证程序良好的可读性。**
```c++
void print(Student&);
```

### new和delete运算符
- 在实际软件开发中，实际上经常需要动态分配和撤销内存空间，毕竟不能在一开始考虑到所有情况然后将所有空间开辟好，那会很浪费空间。
  - C中是用**库函数**`malloc`和`free`来分配和撤销内存空间的，这部分在C++中仍被保留。
  - c++中提供更为简便和功能强大的**运算符**`new`和`delete`来实现空间的分配和撤销。
	- 正因为`new`和`delete`是运算符，不是函数，因此执行效率高。
	- **`new`/`delete`是针对指针操作的操作符**。
- `new`
  - 格式`new 类型[(初值)]`。
  - `new`在分配数组空间时不能指定初始值，因为可能分配失败，此时`new`会返回一个空指针`NULL`，用户要判断是否分配成功。**如果成功返回空间首地址**。
  - 先要定义一个特定类型的指针，再将开辟的新空间首地址返回给该地址变量。
```c++
int*a =new int;//返回一个指针，相当于对一个无名的int变量进行操作
new int(100);//开辟int型变量，并且初始值指定为100
new char[10];
new int[5][4];
float *p=new float(3.1415);
```
- `delete`
  - 使用格式
	- 对变量`delete 指针变量`
	- 对函数`delete [] 指针变量`

- C++的类(class)就是在结构体类型基础上扩充发展而成的。

## 共用体类型
- 共用体：同一段数据空间内存储不同的类型数据。用`union`关键字声明共用体类型。
  - 共用体数据可以出现在结构体的定义中，也可以定义共用体数组。
```c++
union foo{
int i;
char c;
double k;}
```
- 它会适用于对一段空间的数据可以同时采用不同的读取方式的需求。
## 枚举类型
- 当一个变量只有几种类型时，可以定义为**枚举`enumerate`类型**。
- 声明enum类型`enum 枚举类型名 {枚举常量表};`与定义枚举类型变量
  - 其中每一个元素都是枚举元素/枚举常量
```c++
//方式1
enum weekday{sun,mon,tue,wed,thu,fri,sat};//weekday是一类型，可以用于定义变量
weekday weekend;
//方式2
enum {sun,mon,tue,wed,thu,fri,sat} weekend;
```
- 对enum类型的说明
  - 枚举元素按照常量处理，它们的值是固定的。赋值操作是非法的。
  - 枚举元素作为常量，是有值的，其值是一个整数
	- 编译系统按定义时的顺序对它们赋值为0,1,2,3...
	- 也可以在声明枚举类型时自己指定枚举类型的值。
  - 枚举值可以进行比较
  - 枚举**变量**不能被整数赋值，只能被枚举类型数据赋值，因此要进行整数赋值前必须先进行强制转换。
```c++
//编译系统自动赋值
enum{sun,mon,tue,wed,thu,fri,sat}//sun的值为0,后续元素值依次+1
//声明枚举类型时自己指定枚举类型的值
enum {sun=7,mon=1,tue,wed,thu,fri,sat};//元素的值会按照顺序+1
```
- 枚举常量的使用
  - 更直观
  - 而且可以将枚举类型的值限制在定义时规定的几个枚举元素范围内
## typedef
- **注意:用typedef声明的类型名需要用大写字母表示**。
- 声明一个新的类型名来代替已有的类型名
```c++
typedef int INTEGAR;//用于语言迁移
typedef int COUNT;//表意清晰
typedef struct
{int month;
int day;
int year;
}DATE;
```
- 声明一个新的类型名
  - 这种情况下，将原本的定义原型写出，将变量名的位置替换为新类型名，并且在最左加上`typedef`就可以。
```c++
typedef int NUM[100];
NUM n;

typedef char* STRING;
STRING p,s[10];

typedef int (*POINTER)()
POINTER p1,p2;
```
- 其他说明
  - typedef声明的新类型名又称为为typedef类型名
  - typedef不能用于定义变量
  - typedef用于声明数组类型，可以带来很大便利。
  - typedef声明一般放在一个头文件中，在写程序时只需要把头文件包含进来。
  - 好处是便于程序的通用和移植，比如在不同的编译系统中，int类型的长度可能会不一致，这时可以用以下方式一次性修改所有类型名。
```c++
typedef int INTEGAR;
typedef long INTEGAR;
```
