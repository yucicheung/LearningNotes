# 函数
- 一个函数实现一个功能;
- 程序总是从main开始执行，主函数主要用于调用各函数，调用完其他函数之外回到main中结束整个程序。
- C语言中直接在程序单位中定义函数，被认为是面向函数的语言。
- C++中，主函数以外的函数大多是被封装在类中的，可以通过调用类中的函数来实现功能。
## 注意事项
- 函数不可以嵌套定义。
- 其他函数是不能调用main函数的，main由系统调用。
## 知识点
### 定义
- 函数的输入可以定义为`void`，当然也可以省略，也表示不需要输入参数。
- 函数分类
  - 库函数：由编译系统提供，声明在#include的头文件包含。
  - 自定义函数。
- 函数定义
```C++
//无参情况
类型名 函数名([void])
{
声明部分
执行语句
}
//有参情况
类型名 函数名(形参列表)
{
声明部分
执行语句
}
```
- **形式参数和实际参数**
  - 在定义函数时指定的是**形参**,只有进行函数调用时，编译系统才给形参分配内存单元，以接受实参传递的数据，调用结束后，形参占用内存单元释放。
  - 在实际调用函数时，参数列表中的参数是实参。
  - 实参和形参的类型应相同或可以相互转化，以形参类型为准。
  - 实参和形参是不同的单元，形参值的改变不影响实参。
  - 实参对形参变量的数据传递是值传递，数据只能由形参传给实参，不能由形参传回实参。
- `return`
  - 一个函数中可以有一个以上的return语句，只有一个起作用;
  - return后可选加括号;
  - 如果函数类型和return语句中表达式值不同，以函数类型为准。
- 形参求值顺序是不定的，可能从右到左或从左到右。
- **函数声明**是在函数尚未定义的情况下，事先将该函数的有关信息通知编译系统，以使编译时可以对照检查;
  - 库函数的声明用#include<头文件>来实现，一般头文件中会包含一些宏定义信息和对函数的声明;
  - 对于自定义函数，被调用函数在主调函数之后定义时需要提前声明。
- 函数声明也叫**函数原型**(prototype)
  - 编译系统在编译时根据原型对调用合法性做检查，但并不对参数名做检查;
  - 形式
	- 函数类型 函数名(参数类型1,参数类型2...);
	- 函数类型 函数名(参数类型1 参数名1,参数类型2 参数名2...);
### 调用
- 函数虽然不可以嵌套定义，但是可以嵌套调用(显然是的，main中就可以调用其他函数了)。
- **递归调用**：在调用一个函数的过程中又直接/间接调用该函数本身。
  - 包含递归调用的函数称为递归函数。
  - 递归的设计要考虑(1)递归条件，完成递归调用关系处理;(2)基线条件，使递归停止。
  - 递归的时间和空间的开销比较大，但是可读性强;代替递归的通常是循环方法。
### C++特有
- 内置函数/内联函数/内嵌函数(inline function)
  - C++提供的一种高效的方法，即在编译时将所调用函数的代码直接嵌入到主调函数中，而不是将流程转入其他函数;
  - 实际操作是通过将函数体代码替换函数调用语句;
  - 只要在*调用函数之前*将inline的信息告知编译系统，编译系统会在处理函数调用时按内调函数;
  - 内联函数会增加目标程序的长度，因此只将规模很小(一般5个语句以下)而使用频繁的函数声明为内置函数;
  - 使用注意
	- 内置函数中不能包括复杂的控制语句，如循环语句和switch语句;
	- inline是建议性的，不是指令性的，编译系统会根据具体情况决定是否这么做，即系统可以忽略inline声明而当作普通函数处理;

- 函数重载(function overloading)
  - C++允许用一函数名定义多个函数，而函数的参数个数/参数类型可以不同，函数体不需要相同。
  - 注意：
	- 一个函数名可以对应参数类型不同的函数族，也可以对应参数个数不同的函数族，但包含并集时会发生编译器报错;
	- 不能只有函数的类型不同而参数的个数和类型相同;
	- 同名函数的功能应该相近。

- 函数模板
  - C++提供的函数模板就是一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表;
  - 只适用**函数体相同、函数参数个数相同而类型不同的函数**都可以用该模板代替;
  - 在调用函数时会**根据实参的类型来取代模板中的虚拟类型**，从而实现不同功能。
  - 下面`T`代表一个虚拟类型名，T for Type，大写可以跟实际的类型名区分。可以不用T而使用其他标志符。
  - 如果参数类型不止一种，可以根据需要确定个数`template <typename T1,typename T2>`;
```c++
template <typename T>
通用函数定义
//或者
template <class T>
通用函数定义
//两种用法通用
//因为避免和类混淆，所以第一种定义比较清晰，会更常用
```

- 有默认参数的函数：在声明/定义中指定形参默认值;
  - 必须在函数被调用之前，将默认值的信息通知编译系统，重复指定默认值可能会报错;
  - 因为实参与形参的结合是从左到右的顺序进行的，因此指定默认值的参数必须放在形参列表的最右边;
  - 一个函数不能又是重载函数，又是有默认值的函数，因为少写参数时，由于二义性，系统无法判断调用哪个函数。

### 局部和全局变量
- 作用域：变量可以被引用的范围。
  - 文件作用域,file scope
  - 函数作用域,fucntion scope
  - 块作用域,block scope
  - 函数原型作用域,fucntion prototype scope

- 局部变量：在一个**函数内定义**的变量是内部变量，只在本函数范围内有效。
  - **规律：**在`{}`内**定义**的变量只在`{}`内有效。
	- 在复合语句内定义的变量也只在本复合语句范围内有效;
	- 形参也是局部变量，在函数被调用时才生效，也可视为在函数内定义;
	- 函数声明中出现的变量名不占用空间，也不能被引用，会被编译系统忽略。

- 全局变量：在**函数外定义的变量**是全局变量，也叫外部变量。从定义位置开始到源文件结束是其作用域。
  - 全局变量作用是增加函数间数据联系的渠道;
  - 建议不要在不必要时使用全局变量
	- 全局变量在程序的整个执行过程中都占用存储单元;
	- 全局变量会影响程序清晰性。
	- 它使函数通用性降低了，如果要迁移函数到另一个文件，还要将相关的全局变量和其值一起迁移过去，全局变量还可能和其他文件的变量重名。因此设计程序时，划分模块要求模块的内聚性强、与其他模块的耦合性弱。
	- 一般函数要做成一个封闭体，除了“实参-形参”渠道外没有其他渠道，这样的程序移植性好，可读性强。

- 在同一个源文件中，全局变量与局部变量同名，在局部变量的作用范围内，全局变量被屏蔽。

### 存储类别
- 存储期/生命期(storage duration)：变量在内存中存在的周期。
  - 动态存储期(dynamic storage duration)：对应动态存储方式;
  - 静态存储期(static storage duration)：对应静态存储方式。
- 内存中用户使用的存储空间分为3部分：
  - 程序区
  - 静态存储区
  - 动态存储区
- 存储方式
  - 动态存储方式：在程序运行期间，系统对变量动态分配存储空间;
  - 静态存储方式：程序运行期间，系统对变量分配固定存储空间。
- **全局变量全部存放在静态存储区中**，在程序开始执行时给全局变量分配存储单元，程序执行完毕就释放这些空间，期间一直占据固定存储单元。
- 动态存储区中存放：
  - 形参;
  - **函数中定义时未加static的局部变量**。
  - 函数调用时的现场保护和返回地址等。
- 变量的存储类别
  - 自动auto
	- 用`auto`在定义时做存储类别的声明;
	- `auto int b=3,c;`中`auto`和`int`可以顺序替换;
	- `auto`可以省略，默认是自动动态分配存储空间的;
  - 寄存器register
	- 变量一般都是存在内存中的，但C++允许将使用很频繁的变量放在CPU寄存器中，使用时从寄存器取数据，如`register int i;`;
	- 这只是建议性而非指令性的，编译系统一般会自动识别频繁变量并放入寄存器，因此`register`实际上几乎用不到。
  - 外部extern
	- 在一个文件中声明外部变量
  	  - **extern只用来扩展全局变量的作用域，不影响其定义**。
	  - 如，在定义全局变量前要引用其值，需要用extern做*提前引用声明*。
	  - 一般把全局变量定义在最前面，这样就避免在函数中多一个extern声明。
	- 在多文件程序中声明外部变量
	  - 可以让一个文件中定义的全局变量作用域扩展到其他文件中，此时`extern`应在非定义文件中做声明`extern int a;`。
  - 静态static+局部变量
	- 在定义局部变量时用`static`指定为静态局部变量;
	- 使函数中的局部变量值在函数调用结束后不消失而保留值，并在下次调用时可以继续使用。
	- 静态局部变量是在编译时赋初值的，即只赋值一次，其后再调用时，定义部分语句(连同当时的赋初值)不再执行。
	- 在定义静态局部变量时，如没有赋初值，则编译时*默认赋0(数值类型)或者空字符(字符类型)*,而自动变量在这种情况下会是一个不确定的值。
	- 静态局部变量一直存在，但是离开函数调用结束后，其他函数是不能引用的。
	- 如果初始化后，*变量只被引用而不改变值*，此时用局部静态变量是比较合适的。
	- 静态存储占用内存久，且降低可读性，故**如不必要，不要多用**。
 - 静态+全局变量
	- 用于使某些全局变量只限于本文件使用，不能被其他文件引用。
	- 这种只能用于本文件的外部变量成为静态全局/外部变量。
	- 这种方式使每人可以在文件中设计同名的全局变量而不会相互干扰。
- auto,static,register在定义时使用，extern在引用扩展作用域时使用。
### 变量的声明和定义
- 对于函数
  - 函数的声明是函数的原型，函数的定义是功能的确立;
- 对于变量
  - 定义性声明：即定义，需要建立存储空间;
  - 引用性声明：即声明，不需要建立存储空间。
### 内部和外部函数
- 函数本质上是全局的，因为默认是`extern`类型。
- 内部函数`static`
  - 一个函数只能被本文件中其他函数调用，即内部函数;
  - 定义格式为`static 类型标志符 函数名(形参表)`。
  - 使不同文件中的函数名不会互相干扰，其他文件也无法引用本文件中函数。
- 外部函数`extern`
  - 外部函数表示可以被其他文件引用。
  - 是缺省函数类型。
  - 定义时`[extern] 函数类型 函数名(形参列表)`，引用时要声明`[extern] 函数类型 函数名(形参类型)`，即函数原型前加上`extern`,C++允许省略`extern`。
- 函数原型告诉编译系统：该函数将在本文件中稍后定义，或在其他文件中定义。

### 头文件
- 头文件中一般包含几类内容：
  - 对类型的声明
  - 函数声明，如库函数的头文件中就包含了很多函数原型
  - 内置函数定义，内置函数代码要插入用户程序中，因此必须要与调用它的语句在同一文件中
  - 宏定义，#define定义的符号常量和const定义的常变量，值会替代字段。
  - 全局变量定义
  - 外部变量声明
  - 包含其他头文件
- 库函数的头文件中包含函数原型和相关信息，一行#include可以代替很多行内容。
- #include指令可以把不同文件组合在一起，形成一个大文件。头文件是源文件之间的接口。
#### C++标准库和头文件形式
- C++保留了大部分C的系统函数和宏定义外，还增加了预定义的模板和类，但不同编译系统的C++库不一定相同。
- 新C++标准规范了C++标准库，以便于移植。
  - 新C++标准库中的头文件不再包含后缀`.h`，但是兼容这种形式;
  - C++在头文件名前加`c`表示对标准C头文件的继承。
```c++
//c
#include <math.h>
#include <stdio.h>
//c++
#include <cmath>
#include <cstdio>
```
- 一般包含C++标准库头文件时无后缀，包含用户自己的头文件时加后缀，以区分头文件来源。
