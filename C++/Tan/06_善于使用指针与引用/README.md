# 指针
- 指针对于程序效率有很大的提升作用，使用非常灵活。
- 
## 概念
- 内存中每一个字节都有自己的地址，其中存放着数据0,1。变量名在编译后实际上就被转化成变量的地址，而变量的类型决定了系统处理几个单元和如何读取这些数据。
- 变量的空间分配是在编译时完成的。一个变量的地址就是该变量的**指针**。专门用来存放地址的变量是**指针变量**。
- 关于地址的运算符
  - `&`取地址运算符
  - `*`间接寻址运算符(访问到地址对应的变量)
  - `&*指针`或`*&变量`最终值都是自身。
- 存取方式
  - 直接存取/直接访问：按变量地址存取变量值的方式。
  - 间接存取/间接访问：通过存有变量地址的变量(即指针)访问变量值的情况。
	- 单级间址：通过一个指针变量就可以寻址到目标单元。
	- 二级间址：通过两个指针变量才能寻址到取值的目标单元。实际上可以延伸到更多级，但是很少有超过2级的。

## 定义和引用
- 定义形式
  - 指针变量的基类型就是该指针变量指向变量的类型,基类型决定了系统可以如何用该指针操作内存单元，也利于查错。(指针变量是基本数据类型派生出来的类型，不能离开基本类型存在)。
  - 说明：
	- 指针变量的描述应该是'指向x型数据的指针变量'/'x型指针'。
	- 不能用一个整数给一个指针变量赋值，系统会报错。赋值请用`&`符号。
	- 一个指针变量只能指向同一个类型的变量。
```c++
基类型 * 指针变量名
//比如
int *a;
//同时定义多个指针变量
int *pa,*pb;
```
- 指针的使用，通过对内存确定地址直接操作内存单元中内容的方式，在“值传递”(形参单向传递到实参的情况)下保证在子函数中改变的值也能被main函数使用。功能实现类似于返回多个值。

## 数组与指针
- **数组的指针/数组名都是指数组首元素的地址。而指向数组的指针也是取数组首元素的地址。**
```c++
//定义一个int数组
int a[10];
//定义一个指向数组的指针用以下方式
int *pa=a;
//或
int *pa=&a[0];
```
- 指针变量`p`如果已经指向数组中的一个元素(**注意不一定是第一个元素**)，那么**`p+1`则指向数组中的下一个元素**。它代表的地址实际上是`p+1xd`，其中`d`是一个数组元素所占的字节数，这个在编译时进行确认。
  - 如果`p=&a[0]`/`p=a`
	- `p+i`/`a+i`都存储着数组中的第i(从0开始计数)个元素`a[i]`的地址;
	- `*(p+i)`/`*(a+i)`则是由`p+i`/`a+i`中地址寻址到的内存单元，即数组元素`a[i]`所在的内存单元。
	  - 实际上，编译时，对数组元素`a[i]`就是按照`*(a+i)`处理的，即将数组首元素的地址加上相对位移量，找到该元素地址，再读取内容。
	  - `[]`是**变址运算符**：根据值求解实际地址的运算符。
	- 指向数组元素的**指针变量也可以带下标**，如`p[i]`，这样可以理解为其实**指针变量`p`和数组名`a`的作用完全一致**。
- 因此，引用一个数组元素的方法有
  - (1)下标法`a[i]`
	- 下标法的优势是比较直观。
  - (2)指针法`*(a+i)`
	- **指针法使目标程序占用内存少，运行速度快**,举个例子在下面。
	- 注意：指针变量指向的整型对象可能**超过数组范围，在C++编译系统中是合法的**,可能导致程序得不到需要的结果。
```c++
//下标法
a[i++]
//指针法
//省去每次都要用变址运算符进行计算的麻烦
//因此效率高
int *p= a;
for(;p<(a+10);p++)
cout<<*p;
```
- 用指针变量作函数形参接受数组地址，可以直接通过地址操作改变数组的排列。C++编译系统本就是将形参数组名一律作为指针变量处理的(注：**仅在形参传递时**，在形参传递之前的size就是数组占用总字节长度)。
  - 但是**数组名是指针型常量，其值无法改变。**但是形参指针变量是可以改变值的。
```c++
//形参数组名和指针变量一致
//下面两种表达方式一致
void select_sort(int array[],int n)
void select_sort(int *array, int n)
```
## 字符串与指针
- 访问字符串的3种方法
  - 用字符数组存放一个字符串
  - 用字符串变量存放字符串
  - 用字符指针指向一个字符串
```c++
//字符数组
char str[]="I love China";
//字符串变量
string str="I love China";
//字符指针指向一个字符串
char *str="I love China";//字符串常量存储在静态存储区、文本区，输出以碰到`\0`为标记
```
## 函数与指针
- 一个函数在编译时被分配一个入口地址，**函数入口地址就是函数的指针**。可以用一个指针变量指向函数，然后通过该指针变量调用此函数。
- **函数名就是函数的入口地址。**
- 定义指向函数的指针变量的形式`函数类型 (*变量名)(函数形参[类型]表)`，**圆括号一定不能省略**，否则由于`()`优先级高于`*`，声明就成为一个函数声明，例子如下。
  - 调用和函数名调用方法一致。如下例。
```c++
//函数指针定义例子
int (* p)(int,int);
p=max;//max为函数名
p(a,b);//调用函数
```
- 函数可以返回指针类型，返回指针类型的函数即**指针函数**。
  - 定义指针函数`类型名 *函数名(参数表列);`。
## 指针数组和指向指针的指针
- 指针数组：数组中每一个元素都是指针类型数据的数组。
  - 定义形式：`类型名 *数组名[数组长度];`。由于`[]`优先级高于`*`，因此这是一个数组。
- 指向指针的指针：指针间接寻址到的内存单元不是变量值单元，而是存储地址的单元。
  - 定义：`char* (*p);`,p先和`*`结合，表示这是一个指针，指针指向的类型是`char *`。
  - 等价定义形式：`char **p;`。
## const指针
- 指向常量的指针
  - 定义形式`const 类型 *指针变量名;`//因为`const`在类型名前，表示该类型变量的值不能通过指针变量操控来改变。
  - **表示不允许通过指针变量改变它指向的变量的值**;但是指针变量的值是可以改变的，指向的类型变量自身也是可以进行其他赋值的(除非是const型常变量，这种情况下是*指向常变量的指针变量*)，这两点要与前面表述要注意区分。
  - 常用于做函数形参，防止通过指针形参改变所指对象的值。
```c++
//指向常量的指针
int a=12;
const int*p=&a;
//指向常量的指针做函数形参，的函数原型
void fun(const int *p)
{
*p= 5*(*p);//会出错，因为是指向常量的指针，只能引用
}
```
- 常指针
  - 定义形式`类型名 * const 指针变量名;`。//const修饰指针变量，表示其值该保持不变
  - 一些说明：
	- 指定指针变量的值为常量，不能改变。
	- 必须在定义时初始化，确定指向，否则后续赋值会被认为是非法。
	- 此时指针指向变量的值是可以改变的。
```c++
//常指针示例
char *const p1="China";
```
- 指向常量的常指针
  - 定义形式:`const 基本类型名 * const 指针变量名;`。
  - 指针变量的值不能改变，且不能通过操作指针变量改变所指对象的值。
## void指针
- void指针：指向空类型/指向不确定类型(新开辟空间还来不及分配类型)的指针。
  - void指针只提供一个地址，并不提供系统对内存的操作方式。
  - C中的`malloc`函数/C++中的`new`函数开辟动态存储空间时，由于空间尚未使用，还未存储数据，因此谈不上类型，此时只能返回一个`void型指针`。
  - void型指针只是过渡型的，它必须转化为一个确定的数据类型，才能访问实际存在的数据(系统才知道如何读取内存)。因此在实际使用该指针变量时，需要对它进行类型转换。
  - 非void指针可以赋值给void指针，但是void指针在赋给非void型指针时，总是需要先进性强制类型转换。
```c++
void *p;
//强制类型转换才能正确读取
cout<<(char*)p;
```

## 其他用法
- 指针变量是可以有空值的，表示该指针变量不指向任何变量。`p=NULL;`。**NULL只能赋给指针变量。**
  - 在VC++和某些编译系统的<iostream>头文件中，已经规定NULL表示0。因此定义为NULL，就是使指针指向地址为0的内存单元。但某些编译系统中并不是如此规定的。
- 两个指针变量相减
  - 比如两个变量都指向数组中的不同元素，相减表示中间相隔的元素个数。
- 指针的比较
  - 当两个指针变量都指向同一个数组中的元素，就可以进行比较。指向前面的元素的指针变量小于指向后面的元素的指针变量。(因为是+n的关系)。
- 指针之间的赋值需要保持类型一致。比如可以通过强制类型转换。
## 引用
- **引用**(reference)是C++中的一个专有名词。是C++对C的一个重要扩充。
- 对一个数据建立一个“引用”，它的作用是为一个变量起一个**别名**。
  - 定义形式如下，其中的`&`是**引用声明符**。
```c++
int a;
int &b=a;//b是对变量a的引用，也b是a的别名
```
- 关于引用的说明：
  - **引用的本质是指针**
	- 就是开辟一个指针型的存储单元b，其中存放被引用的变量a的地址，引用变量b时就是输出*b。
	- 引用其实就是一个指针常量，它的指向不能改变，只能指向一个指定的变量。
  - 引用不是一种独立的数据类型，对引用只有声明。必须先定义一个变量，然后对该变量建立引用。
  - 声明一个引用时，必须同时使之初始化(除非是作为形参传递)。
  - 在作为一个变量的引用后，不能再作为另一个变量的引用。
  - 不能建立引用数组。
  - 不能建立引用的引用，也没有引用的指针。
  - 可以取引用的地址，就是其代表的变量的地址。
  - 区别引用声明符和地址运算符。
- 引用的使用
  - 作为变量的引用
```c++
int a=10;
int &b=a;
cout<<b;
```
  - 除变量以外，引用还可以用于类对象。
  - 引用作为函数参数，扩充函数参数传递数据的功能：
	- c++通过把引用作为函数形参，提供了向函数传递参数的**地址传递方式**，形参是实参的别名，对形参的调用就实现对实参的调用。
	- 传递时，实参是变量名，而传递的却是变量的地址，这才是传址方式，否则都是传值方式。
```c++
//引用作为形参的函数声明
void swap(int&,int&);
```
