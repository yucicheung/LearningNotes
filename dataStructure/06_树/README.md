# 树
## 树的定义
树(Tree)是n(n>=0)个结点的有限集。n=0时称为空树。
在任意一棵非空树中：(1)有且仅有一个特定的称为根(Root)的结点;(2)当n>1时，其余结点可以分为m(m>0)个互不相交的有限集T1、T2、....Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。

**注意**：
1. n>0时根结点是唯一的，不可能存在多个根结点。
2. m>0时，子树的个数没有限制，但它们一定是互不相交的。

### 结点分类
结点拥有的子树数称为**结点的度**(degree)。
- 度为0的结点称为叶结点(Leaf)或终端结点;
- 度不为0的结点称为非终端结点或分支结点。
  - 除根结点之外，分支结点也称为内部结点。

**树的度**是树内各**结点的度的最大值**。

### 结点间关系
结点的子树的根称为该结点的**孩子(child)**，该结点称为孩子的**双亲(parent)**。
同一个双亲的孩子之间互称**兄弟(Sibling)**。
结点的**祖先**是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的**子孙**。

### 树的其他概念
**结点的层次(Level)**从根开始定义起，**根为第一层**，根的孩子为第二层。
双亲在同一层的结点称为**堂兄弟**。
树中结点的最大层次称为**树的深度(Depth)**或高度。(有几层结点，深度就是几)。
如果将书中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为**有序树**，否则称为**无序树**。
**森林(Forest)**是m(m>=0)棵互不相交的树的集合。对树中每个结点，其子树的集合即为森林。

## 树的抽象数据类型

```c
ADT 树(tree)
Data
	树是由一个根结点和若干棵子树构成。
	树中结点具有相同数据类型及层次关系。
Operation
	InitTree(*T):构造空树T
	DestroyTree(*T):销毁树T
	CreateTree(*T,definition):按definition中给出树的定义来构造树
	CrearTree(*T):若树存在，则将树T清空
	TreeEmpty(T):若T为空树，返回true，否则返回false
	TreeDepth(T):返回T的深度
	Root(T)：返回T的根结点
	Value(T,cur_e):cur_e是树T中的一个结点，返回此结点的值
	Assign(T,cur_e,value):给树T的结点cur_e分配值value
	Parent(T,cur_e):若cur_e是树T的非根结点，则返回它的双亲，否则返回空
	LeftChild(T,cur_e)：若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空
	RightSibling(T,cur_e):若cur_e有右兄弟，则返回它的右兄弟，否则返回空
	InsertChild(*T,*p,i,c):p指向树T的某个结点，i为所指结点p的度+1，c为与T不相交的树，此操作是将c树插入到p所指的结点作为其第i棵子树
	DeleteChild(*T,*p,i):其中p指向树T的某个结点，i为所指结点p的度，操作删除T中p所指结点的第i棵子树
endADT
```

## 树的存储结构
树是一对多的结构，简单的是顺序存储和链式存储是不能满足实现要求的，但我们可以充分利用这些结构的特点。
对于树的存储结构的表示：
- 双亲表示法
- 孩子表示法
- 孩子兄弟表示法

### 双亲表示法
对于树，除根结点外，其余每个结点，不一定有孩子，但是一定有且仅有一个双亲。
每个结点中，附设一个指示器指示其双亲结点在数组中的位置，即每个结点包含两个域：一个**data**是数据域，存储结点的数据信息;一个**parent**是指针域，存储结点的双亲在数组中的下标。

双亲表示法的结点结构定义代码：
```c
#define MAX_TREE_SIZE 100
typedef int TElemType;
typedef struct PTNode	//树结点
{
	TElemType data;	//结点数据
	int parent;		//双亲位置
}PTNode;
typedef struct			//树结构
{
	PTNode nodes[MAX_TREE_SIZE];//结点数组
	int r,n;			//根的位置和结点数
}PTree;
```

**约定**：根结点的位置域设置为-1。

则整个树的表示就是
| 下标 | data | parent |
| --- | --- | --- |
| 0 | A | -1 |
| 1 | B | 0 |
| 2 | C | 0 |
| 3 | D | 1 |
| 4 | E | 2 |
| 5 | F | 2 |

**分析**:这种表示方法下，如果要找到结点的双亲结点，所用的时间复杂度是O(1)。但*如果要知道结点的孩子，必须遍历整个结构才行*。

根据具体的情况，如果是要将孩子信息包含，则可以添加一个长子域，记录结点最左边孩子的域。这样就可以很容易得到结点的孩子。
如果是关注兄死之间的关系，可以增加一个右兄弟域来体现兄弟关系。
**存储结构的设计是一个非常灵活的过程**。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。

## 孩子表示法
因为树的每个结点可能有多棵子树，可以考虑用**多重链表**：即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示方法。

由于每个结点的度不同，我们可以设计两种方法解决：
1. 指针域的个数等于树的度(树的度就是各结点的度的max)。
  - 则data是数据域，child1-childd是指针域。
  - 显然在树中各结点的度相差很大时，非常浪费空间。
2. 每个结点指针域的个数等于该结点的度(专门取一个位置来存储结点指针域的个数degree)
  - 则data是数据域，degree是度域，即该结点的孩子结点的个数，child1-childd为指针域，指向该结点各孩子的结点。
  - 克服了浪费空间的缺点，但是因为需要维护结点的度的数值，在运算上就会带来时间上的损耗。
