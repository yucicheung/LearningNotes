# 树
## 树的定义
树(Tree)是n(n>=0)个结点的有限集。n=0时称为空树。
在任意一棵非空树中：(1)有且仅有一个特定的称为根(Root)的结点;(2)当n>1时，其余结点可以分为m(m>0)个互不相交的有限集T1、T2、....Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。

**注意**：
1. n>0时根结点是唯一的，不可能存在多个根结点。
2. m>0时，子树的个数没有限制，但它们一定是互不相交的。

### 结点分类
结点拥有的子树数称为**结点的度**(degree)。
- 度为0的结点称为叶结点(Leaf)或终端结点;
- 度不为0的结点称为非终端结点或分支结点。
  - 除根结点之外，分支结点也称为内部结点。

**树的度**是树内各**结点的度的最大值**。

### 结点间关系
结点的子树的根称为该结点的**孩子(child)**，该结点称为孩子的**双亲(parent)**。
同一个双亲的孩子之间互称**兄弟(Sibling)**。
结点的**祖先**是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的**子孙**。

### 树的其他概念
**结点的层次(Level)**从根开始定义起，**根为第一层**，根的孩子为第二层。
双亲在同一层的结点称为**堂兄弟**。
树中结点的最大层次称为**树的深度(Depth)**或高度。(有几层结点，深度就是几)。
如果将书中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为**有序树**，否则称为**无序树**。
**森林(Forest)**是m(m>=0)棵互不相交的树的集合。对树中每个结点，其子树的集合即为森林。

## 树的抽象数据类型

```c
ADT 树(tree)
Data
	树是由一个根结点和若干棵子树构成。
	树中结点具有相同数据类型及层次关系。
Operation
	InitTree(*T):构造空树T
	DestroyTree(*T):销毁树T
	CreateTree(*T,definition):按definition中给出树的定义来构造树
	CrearTree(*T):若树存在，则将树T清空
	TreeEmpty(T):若T为空树，返回true，否则返回false
	TreeDepth(T):返回T的深度
	Root(T)：返回T的根结点
	Value(T,cur_e):cur_e是树T中的一个结点，返回此结点的值
	Assign(T,cur_e,value):给树T的结点cur_e分配值value
	Parent(T,cur_e):若cur_e是树T的非根结点，则返回它的双亲，否则返回空
	LeftChild(T,cur_e)：若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空
	RightSibling(T,cur_e):若cur_e有右兄弟，则返回它的右兄弟，否则返回空
	InsertChild(*T,*p,i,c):p指向树T的某个结点，i为所指结点p的度+1，c为与T不相交的树，此操作是将c树插入到p所指的结点作为其第i棵子树
	DeleteChild(*T,*p,i):其中p指向树T的某个结点，i为所指结点p的度，操作删除T中p所指结点的第i棵子树
endADT
```

## 树的存储结构
树是一对多的结构，简单的是顺序存储和链式存储是不能满足实现要求的，但我们可以充分利用这些结构的特点。
对于树的存储结构的表示：
- 双亲表示法
- 孩子表示法
- 孩子兄弟表示法

### 双亲表示法
对于树，除根结点外，其余每个结点，不一定有孩子，但是一定有且仅有一个双亲。
每个结点中，附设一个指示器指示其双亲结点在数组中的位置，即每个结点包含两个域：一个**data**是数据域，存储结点的数据信息;一个**parent**是指针域，存储结点的双亲在数组中的下标。

双亲表示法的结点结构定义代码：
```c
#define MAX_TREE_SIZE 100
typedef int TElemType;
typedef struct PTNode	//树结点
{
	TElemType data;	//结点数据
	int parent;		//双亲位置
}PTNode;
typedef struct			//树结构
{
	PTNode nodes[MAX_TREE_SIZE];//结点数组
	int r,n;			//根的位置和结点数
}PTree;
```

**约定**：根结点的位置域设置为-1。

则整个树的表示就是
| 下标 | data | parent |
| --- | --- | --- |
| 0 | A | -1 |
| 1 | B | 0 |
| 2 | C | 0 |
| 3 | D | 1 |
| 4 | E | 2 |
| 5 | F | 2 |

**分析**:这种表示方法下，如果要找到结点的双亲结点，所用的时间复杂度是O(1)。但*如果要知道结点的孩子，必须遍历整个结构才行*。

根据具体的情况，如果是要将孩子信息包含，则可以添加一个长子域，记录结点最左边孩子的域。这样就可以很容易得到结点的孩子。
如果是关注兄死之间的关系，可以增加一个右兄弟域来体现兄弟关系。
**存储结构的设计是一个非常灵活的过程**。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。

### 孩子表示法
因为树的每个结点可能有多棵子树，可以考虑用**多重链表**：即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示方法。

由于每个结点的度不同，我们可以设计两种方法解决：
1. 指针域的个数等于树的度(树的度就是各结点的度的max)。
  - 则data是数据域，child1-childd是指针域。
  - 显然在树中各结点的度相差很大时，非常浪费空间。
2. 每个结点指针域的个数等于该结点的度(专门取一个位置来存储结点指针域的个数degree)
  - 则data是数据域，degree是度域，即该结点的孩子结点的个数，child1-childd为指针域，指向该结点各孩子的结点。
  - 克服了浪费空间的缺点，但是因为需要维护结点的度的数值，在运算上就会带来时间上的损耗。

更好的表示方法**孩子表示法**：每个结点放到一个顺序存储的数组中，再对每个结点的孩子建立一个单链表体现它们的关系。如果是叶结点，则孩子链表为空。
孩子表示法的结构定义代码：
```c
#define MAX_TREE_SIZE 100
typedef struct CTNode
{
	int child;
	CTNode* next;
}*ChildPtr;

typdef struct
{
	TElemType data;
	ChildPtr firstChild;
}CTBox;

typedef struct
{
	CTBox nodes[MAX_TREE_SIZE];
	int r,n;	//根的位置和结点数
}CTree;
```
当然你也可以将双亲表示法和孩子表示法结合起来，使双亲查找也能更简单。

将复杂的树变为二叉树的表示方法：**孩子兄弟表示法**
原理：任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。
```c
//树的孩子兄弟表示法结构定义
typedef struct CSNode
{
	TElemType data;
	struct CSNode * firstchild,*rightsib;
}CSNode,*CSTree;//CSTree是树的头结点
```

## 二叉树的定义
> 二叉树(Binary Tree)是n(n>=0)个结点的有限集合，该集合或者为空集(空二叉树)，或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。

### 二叉树特点

如下：
- 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。
- **左子树和右子树是有顺序的，**次序不能任意颠倒。
- 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

由此决定了二叉树的五种基本形态：
1. 空二叉树
2. 只有一个根节点
3. 根节点只有左子树
4. 根结点只有右子树
5. 根结点既有左子树又有右子树

### 特殊二叉树
- 斜树
所有结点都只有左子树的二叉树叫做左斜树；所有结点都只有右子树的斜树叫做右斜树。
斜树的特点是：每一层只有一个结点，结点的个数与二叉树的深度相同。

- 满二叉树
在一棵二叉树中，如果所有的分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的树就是满二叉树。
故满二叉树的特点有：
1. 叶子只能出现在最下一层
2. 非叶子结点的度一定是2
3. 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多

- 完全二叉树
对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同，则该二叉树称为完全二叉树。
完全二叉树的特点如下：
1. 叶子结点只能出现在最下两层
2. 最下层的叶子一定集中在左部连续位置
3. 倒数二层，若有叶子结点，一定都在右部连续位置
4. 如果结点度为1，则结点只有左孩子，不存在只有右子树的情况
5. 同样结点数的二叉树，完全二叉树的深度最小

## 二叉树性质
- 性质1：在二叉树的第i层上之多有2^(i-1)个结点(i>=0)。
- 性质2：深度为k的二叉树至多有2^k-1个结点。
- 性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1；
```
//推导
n = n0+n1+n2 //结点数
n-1 = n1+2n2 //分支数
```
- 性质4：具有n个结点的完全二叉树的深度为`floor(log2(n))+1`
- 性质5：如果对一棵有n个结点的完全二叉树(其深度为`floor(log2(n))+1`)的结点按层序编号，对任一结点i(1<=i<=n)有：
  - 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点`floor(i/2)`；
  - 如果2i>n，则结点i无左孩子(结点i为叶子结点），否则其左孩子结点是2i；
  - 如果(2i+1)>1，则结点i无右孩子，否则其右孩子结点是2i+1。

## 二叉树的存储结构
### 顺序存储结构
利用完全二叉树的层序编号，可以直接按照层序编号将各结点放入数组中。
如果要将非完全的二叉树用顺序结构存储，在没有结点的地方设置为空，可能会非常浪费存储空间，因此**顺序存储结构只适合完全二叉树**。

### 二叉链表
二叉树每个结点最多有两个孩子，因此设计每个结点拥有**一个数据域，和两个指针域**是比较自然的想法，这样的链表称为二叉链表。

二叉链表的结点结构定义代码：
```c
typedef struct BiTNOde
{
	int data;
	struct BiNode *lchild, rchild;
}BiTNode,*BiTree;
```
对非完全二叉树的也不会过分浪费空间。

## 遍历二叉树

