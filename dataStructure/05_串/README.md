# 串String
串(String)是由零个或多个字符组成的有限序列，又名字符串。
## 串的定义
串(String)是由零个或多个字符组成的有限序列，又名字符串。

一般记为s="a1a2....an"(n>=0)，其中s是串的名称，用双引号(或者单引号)括起来的字符序列是串的值，注意引号不属于串的内容。ai(1<=i<=n可以是字母、数字或其他字符，i是该字符在串中的位置。串中的字符数目n称为串的长度，零个字符的串称为空串(null string)。所谓的序列，说明串的相邻字符之间具有前驱和后继关系。

其他概念：
- 子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，包含子串的串称为主串。
- 子串在主串中的位置时子串的第一个字符在主串中的序号。

## 串的比较
串的比较时用该串的字符之间的编码(字符的编码值得时字符在对应字符集中的序号)来进行的。
- ASCII是使用8位二进制数表示一个字符，后来的Unicode编码用16位的二进制数表示一个字符，为了兼容前者，Unicode的256个字符时与ASCII码完全兼容。

串的大小比较：给定两个串`s="a1a2...an"`，`t="b1b2...bm"`，当满足下列条件之一时,`s<t`。
1. n<m时，且ai=bi(i=1,2...n)。
2. 存在某个k<=min(m,n),使得ai=bi(i=1,2,...k-1),ak<bk。

## 串的抽象数据类型
串的逻辑结构类似于线性表，不同之处在于串针对的是字符集。在串中更关注的是查找子串位置、得到指定位置子串、替换子串等操作。
```
ADT 串(string)
Data
    串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。
Operation
    StrAssign(T,*chars):生成一个其值等于字符串常量chars的串T
    StrCopy(T,S):串S存在，由串S复制得串T
    ClearString(S):若串存在，将串清空
    StringEmpty(S):若串为空，返回True;否则返回false
    StrLength(S):返回串S的元素个数，即串的长度
    StrCompare(S,T):若S>T，返回值>0;若S=T,返回0;否则返回值小于0
    Concat(T,S1,S2):用T返回由S1,S2联接而成的新串
    SubString(Sub,S,pos,len):串S存在,pos和len合法，用Sub返回串S的第pos个字符之后第一次出现的位置，否则返回0
    Index(S,T,pos):串S,T存在，T是非空串，若主串S中存在和串T中相同的子串，则返回它在主串S中第pos个字符之后法第一次出现的位置，否则返回0
    Replace(S,T,V):串S、T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串
    StrInsert(S,pos,T):串S与T存在，pos合法，在串S的第pos个字符之前插入串T
    StrDelete(S,pos,len):串S存在，pos合法，从串S中删除第pos个字符起长度为len的子串
endADT
```

- 一个操作Index的实现算法
```c
//T为非空串。若主串S中第pos个字符之后存在与T相等的子串
//则返回第一个这样的子串在S中的位置，否则返回0
int Index(String S,String T, int pos)
{
	int n,m,i;
	String sub;
	if(pos>0)
	{
		n = StrLength(S);
		m = StrLength(T);
		i = pos;
		while(i<n-m+1)
		{
			SubString(sub,S,i,m);
			if(!StrCompare(sub,T)) i++;
			else return i;
		}
	}
	return 0;
}
```

- 串的顺序存储结构:是一组地址连续的存储单元来存储串中的字符序列的，在字符数超出数组长度时或者进行上溢报错，或者进行字符串截尾。
- 串的链式存储结构，在程序执行过程中动态分配而得。在计算机中的自由存储区，叫"堆"中进行开辟回收空间，而在C语言中使用动态分配函数malloc()和free()来管理
  - 在链式的存储结构中，结构中的每个元素数据是一个字符，如果一个结点只对应一个字符，会存在很大的空间浪费(char占用一个字节，但地址可能占多个字节)。因此考虑一个几点存放多个字符，最后一个结点如果没有占满，可以用"#"或其他非串值字符补全。
  - 在连接串时有一定方便之外，不如顺序存储灵活，性能也不如顺序存储好。

## 模式匹配算法
假设我们要计算在一篇文档中使用频率最高的词汇，这就是找一个单词在一篇文章中的定位问题，这种**子串的定位操作通常称为串的模式匹配**是串中最重要的操作之一。
###朴素的模式匹配算法
- 对主串的每一个字符作为子串的开头，与要匹配的字符串进行匹配，对主串做大循环，每个字符开头做T的长度的小循环，知道匹配成功或全部遍历完成为止。
  - 最好的情况是O(1)，一开始就匹配成功;
  - 差的情况是`O((n-m+1)*m)`，即每一次不成功的匹配都发生在串T的最后一个字符。**而这种情况在计算机中是很常见的**，因为计算机中处理的都是0和1的串，所以朴素模式匹配太低效了。

### KMP模式匹配算法
针对有多个0和1重复字符的字符串，模式匹配需要挨个遍历的算法是很糟糕的。
**KMP算法，可以大大避免重复遍历的情况**。
- KMP模式匹配算法原理
  - 主串中的**i值绝不回溯**，只有j值可以回溯;
  - j值的变化跟主串没什么关系，取决于T串的结构中是否有重复的问题，j值的多少取决于当前字符之前的串的前后缀的相似度。

关于T串的各个位置的**j值变化定义为一个数组next**，则next的长度就是T串的长度，于是可以得到下列的函数定义：
根据经验，如果前后缀一个字符相等，k值是2,两个字符k值是3,n个相等k值就是n+1。
Detail:在T串第j个字符前画线，在线前面的字符串中划分，从第一个开始字母计算前缀，从线前最近一个字符开始计算后缀，依次向中间靠拢，能够找到的最长的字符子串长度就是n，则 k=n+1(**这也就是对子串的处理算法，如何找到最大的n:从两边向中间各获取前缀和后缀，从而得到最长的重复子串**)。
```
next[j]=
	0,当j=1时;
	Max{k|1<k<j,且`p_1...p_{k-1}`=`p_{j-k+1}...p_{j-1}`},当集合不空时;
	1,其他情况
```

- 计算出当前要匹配的串T的next数组如下：
```c
/*通过计算返回子串T的next数组*/
//针对子串T操作
void get_next(String T, int *next)
{
	int i,j;
	i = 1;//i值绝不回溯，可以当作后缀
	j = 0;
	next[1]=0;
	while(i<T[0])
	{
		if(j==0 || T[i]==T[j])	//T[i]表示后缀单个字符，T[j]表示前缀单个字符
		{
			++i;
			++j;
			next[i]=j;	//如果相同则一致前移，不回溯
		}
		else j = next[j];		//若字符不同，则j值回溯，回溯到上一次相同子串的位置处，那以后判断是否字符可以相同。
	}	
}
```

- KMP的实现算法如下：
```c
//返回字串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。
//T非空，1<=pos<=StrLength(S)
int Index_KMP(String S,String T,int pos)
{
	int i = pos;
	int j = 1;
	int next[255];
	get_next(T,next);
	while(i<=S[0]&&j<=T[0])	//各数组0位存放了各自数组长度
	{
		if (j==0||S[i]==T[j])
		{
			j++;
			i++;
		}
		else j = next[j];
	}
	if(j>T[0])//当遍历到T的最后一个元素时，说明已经在S中找到与T相同的子串
	{
		return i-T[0];
	}
	else return 0;
}
```
由于i值不回溯，使得index_KMP算法效率得到了提升，时间复杂府为O(n+m)。
KMP算法仅当模式与主串之间存在许多“部分匹配”的情况时，才能体现优势，否则差异不明显，都是O(m+n)。

### KiMP模式匹配算法改进
KMP算法中存在的一个问题就是，如碰到`aaaabcde`这种字符串时，next数组是012345，当T="aaaaax"时，`j=next[j]`会逐个往前递归，而实际上只要进行`j=next[1]`就能避免多次循环。
因此对KMP算法的改进如下：
```c
//改进的next函数，将next存入nextval
//改进针对的是**有很多重复字符的情况**
void get_nextval(String T,int *nextval)
{
	int i,j;
	i = 1;	//i是后缀
	j = 0;	//j是next数组的值
	nextval[1]=0;
	while(i<T[0])	//对T中每一个字符都会有相应的next数值
	{
		if(j==0 || T[i]==T[j])
		{	//元素相等则一致前移
			++i;
			++j;
			if(T[i]!=T[j])		//当后面跟着的的字母不相等时，代表无重复，所以正常赋值即可
				nextval[i]=j;
			else				//代表有重复，那么nextval[i]应该获得上一次相同字符串/重复子串的值，避免重复进行查找。
				nextval[i]=nextval[j];
		}
		else
			//元素不等则回溯
			j = nextval[j];
	}
}
```
**总结**：改进过的KMP算法，是在计算出next值的同时，如果a位字符与它的值指向的b位字符相等，则该a位的nextval就指向b位的nextval值，如果不相等，则该a位的nextval值就是它自己a位的next的值。


