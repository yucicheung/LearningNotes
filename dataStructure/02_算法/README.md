# 算法
## 算法定义
- **算法：是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。**
  - 指令是能被人或机器等计算装置执行，可以是计算机指令，也可以是我们平时的语言文字。
  - 为了解决某个或某类问题，需要把指令表示成一定的操作序列，操作序列包括一组操作，每一个操作都完成指定的功能，这就是算法。

## 算法的特性
**五个特性：输入、输出、有穷性、确定性和可行性。**
- 输入输出：
  - 算法有零个或多个输入。
  - 算法至少有一个或多个输出。
- 有穷性：指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。
  - 这里的有穷应是在实际应用当中合理的，可以接受的“有边界”。
- 确定性：算法的每一步骤都具有确定的含义，不会出现二义性。(二义性应该会被编译器预编译时检验出）
- 可行性：算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成。  - 可行性意味着算法可以转换为程序上机运行，并得到正确的结果。

## 算法设计的要求(好的算法)
算法不是唯一的。

- 正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。“正确”体现在以下四个层次：
  - 算法程序没有语法错误。
  - 算法程序对于合法的输入数据能够产生满足要求的输出结果。
  - 算法程序对于非法的输入数据能够得出满足规格说明的结果。（容错性、异常处理，应作为一个算法是否正确的最低标准）
  - 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。（测试）

- 可读性：算法设计的另一目的是为了便于阅读、理解和交流。
  - 可读性高有助于人们理解算法，难懂晦涩的算法往往隐含错误，不易被发现，且难于调试和修改。
  - 写代码不仅是为了让计算机执行，也是为了便于他人或自己阅读，让大家理解和交流。
  - 可读性是算法好坏的很重要标志。

- 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。

- 时间效率高和存储量低（时空复杂度）
  - 时间效率(时间复杂度)指的是算法的执行时间，执行时间短的算法效率高，执行时间长的效率低。
  - 存储量(空间复杂度)指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。

好的算法应该具有正确性、可读性、健壮性、高效率和低存储量的特点。

## 算法效率的度量方法
- 事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。出于以下原因，我们通常不采纳这种方法。
  - 必须依据算法事先编制好程序，通常需要花费大量时间和精力;
  - 时间的比较会很依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣;
  - 算法的测试数据设计困难，且程序的运行时间往往与测试数据的规模有很大关系，效率高的算法在小的测试数据面前往往得不到体现;

- 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。
  - 高级程序语言程序的运行时间通常取决于以下因素
	- 算法采用的策略、方法(算法好坏的根本)
	- 编译产生的代码质量(由软件支持)
	- 问题的输入规模
	- 机器执行指令的速度(硬件性能)
  - 测试运行时间最可靠的方法是**计算对运行时间有消耗的基本操作的执行次数**，运行时间与这个计数成正比,**且要把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数。**
  - 最终在分析程序运行时间时，最重要的就是把程序看成是独立于程序设计语言的算法或一系列步骤。

## 函数的渐进增长

- 函数的**渐进增长**：给定两个函数f(n)和g(n)，如果存在一个整数N,使得对于所有的n>N，f(n)总是比g(n)大，那么就说f(n)的增长渐进快于g(n)。

- 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数。

## 算法时间复杂度

- 算法时间复杂度定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记做：T(n)=O(f(n))。表**示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同**，称作算法的渐进时间复杂度，简称为时间复杂度。其中，f(n)是问题规模n的某个函数。
  - 这种用大写O()体现算法时间复杂度的记法，我们称之为大O记法。
  - 一般情况下，随着n的增大，T(n)增长最慢的算法是最优算法。

- **推导大O阶方法**
  1. 用常数1取代时间中的所有加法常数。
  2. 在修改后的运行次数函数中，只保留最高阶项。
  3. 如果最高阶存在且不是1,则去除与这个项目相乘的常数。

- 一些常用的算法时间复杂度（在计算时间复杂度时应该用上述推导方法得到准确阶数）

| 执行次数函数 | 阶 | 非正式术语 |
| --- | --- | --- |
| 12 | O(1) | 常数阶 |
| 2n+3 | O(n) | 线性阶 |
| 3n^2+2n+1 | O(n^2) | 平方阶 |
| 5log_2*n*+20 | O(log*n*) | 对数阶 |
| 2n+3nlogn+19 | O(nlog*n*) | nlogn阶 |
| 6n^3+2n^2+3n+4 | O(n^3) | 立方阶 |
| 2^n | O(2^n) | 指数阶 |

```
//它们所耗费的时间从小到大依次是
O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
//指数阶和阶乘阶对稍大的n都会是噩梦般的运行时间
```

## 最坏情况与平均情况

- 最坏时间复杂度：最坏情况运行时间是一种保证，那就是运行时间不会再坏了，在应用中，这是一种最重要的需求，通常，**除非特别指定，所提到的运行时间都是最坏情况的运行时间。**

- 平均时间复杂度：平均运行时间是所有情况中最有意义的，因为是期望的运行时间。但现实中，平均运行时间很难通过分析得到，**一般通过运行一定数量的实验数据后估算得到**。

## 算法空间复杂度

- 算法上，我们可以尝试用空间换时间(但通常好的算法是时间和空间开销都会小的)。

- 算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：`S(n)=O(f(n))`，其中n为问题的规模，f(n)为语句关于n所占存储空间的函数。
  - 一般情况下，一个程序执行时，除需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。
  - 若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。
  - 复杂度通常是指时间复杂度。


