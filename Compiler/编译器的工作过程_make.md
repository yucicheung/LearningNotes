# [C++编译器的工作过程](http://www.ruanyifeng.com/blog/2014/11/compiler.html)
以`gcc`为例说明，
```c++
//test.c
#include<stdio.h>
int main(void)
{
	fputs("Hello,world!\n",stdout);
	return 0;
}
```
- 对于简单的源代码，只要进行`gcc`命令后执行可执行文件即可。
```shell
gcc test.c
./a.out
```
- 对于复杂的项目，编译需要分为以下三步
```shell
./configure
make
make install
```
我们主要借以上三个命令各自的任务来介绍编译器的工作。编译器的基本工作流程(C/C++)如下

![编译器工作过程](编译器工作过程.png)

## 第一步 配置(configure)
编译器在开始工作之前，需要知道当前的系统环境，如标准库在哪里、软件的安装位置等等。不同计算机的系统环境不同，在指定编译参数后，编译器就可以适应环境，编译出各种环境都能运行的机器码，这个确定编译参数的步骤，就是**“配置”(configure)**

配置信息保存在一个配置文件中，约定俗成是一个叫做configure的脚本文件(通常它是由`autoconf`工具生成的)，编译器通过运行这个脚本，编译参数。

configure脚本已经考虑到不同系统的差异，并且*对各种编译参数给出了默认值*。如果用户环境特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。
```shell
# php源码的一种编译配置，用户指定安装后的文件保存在www目录，并且在编译时加入对mysql模块的支持
./configure --prefix=/www --with-mysql
```

## 第二步 确定标准库和头文化的位置
源码肯定会用到标准库函数(standard library)和头文件(header)。这些文件可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。

**编译的第二步就是，从配置文件中知道标准库和头文件的位置。**一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。

## 第三步 确定依赖关系
**对于大型项目来说，源码之间往往存在依赖关系，编译器需要确定编译的先后顺序。**假设A文件依赖于B文件，编译器应该保证做到下面两点
1. 只有B文件编译完成后，才开始编译A文件;
2. 当B文件发生变化时，A文件会被重新编译。

编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。而**makefile文件由configure脚本运行生成，这就是编译时configure必须首先运行的原因。**

依赖关系确定的同时，编译器也确定了，编译时会用到哪些头文件。(按顺序append)

## 第四步 头文件的预编译(precompilation)
不同的源码文件，可能引用同一个头文件，那么在编译时，头文件也必须一起编译。为了节省时间，**编译器会在编译源码之前，先编译头文件，这保证头文件只编译一次**，不用在每次用到时，都重新编译。

但不是头文件的所有内容都会被预编译，*用来声明宏的`#define`命令，就不会被预编译。*

## 第五步 预处理(Preprocessing)
预编译完成后，编译器就开始替换掉源码中的头文件和宏。以本文开头的那段源码为例，它包含头文件stdio.h，替换后的样子如下：
```c++
extern int fputs(const char*,FILE *);
extern FILE *stdout;

int main(void)
{
	fputs("Hello,world!\n",stdout);
	return 0;
}
```

上面代码只截取了头文件中与源码相关的那部分，即fputs和FILE的声明，由于内容过长，省略了stdio.h的其他部分。*上面代码的头文件没有经过预编译，而实际上，插入源码的是预编译的结果(二进制机器码)*。编译器在这一步还会移除注释。

这一步称为**预处理(preprocessing)**，之后就要进行真正的处理了。

## 第六步 编译(Compilation)
预处理之后，编译器就会开始生成机器码。对于某些编译器来说，还存在一个中间步骤，会先把源码转为汇编码(assembly)，再把汇编码转为机器码。

**转码(二进制码)后的文件就叫对象文件(object file)**。

## 第七步 连接(Linking)
对象文件还不能运行，需要进一步转为可执行文件。

编译器的下一步工作，就是把外部函数的代码(通常是后缀为`.lib`和`.a`的文件)，如标准库中的代码，添加到可执行文件中，这就叫做连接(linking)。这种**通过拷贝，将外部函数库添加到可执行文件的方式，叫做静态连接(static linking)。**

**`make`命令的作用，就是从第四步文件预编译开始，一直到这一步。**

## 第八步 安装(Installation)
上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。

表面上，这一步很简单，就是将可执行文件(连带相关的数据文件)拷贝过去就行。但实际上，**这一步还必须完成创建目录、保存文件、设置权限等步骤**。这整个的保存过程就称为"安装(Installation)"。

## 第九步 操作系统连接
可执行文件安装后，必须以某种方式通知操作系统(比如win下注册，ubuntu下软件管理器)，这样比方我们安装一个文本阅读程序后，往往双击txt文件，该程序就会自动运行。

这就**要求在操作系统中，登记这个程序的元数据：文件名、文件描述、关联后缀名等。**Linux系统中，这些信息通常保存在`/usr/share/applications`目录下的`.desktop`文件中。在Win下，还需要在Start启动菜单中，建立一个快捷方式。

这些事情就叫做"操作系统连接"。` install`就用来完成"安装"和"操作系统连接"两步。

## 第十步 生成安装包
到这里，源码编译的整个过程就基本完成了。但是不能要求客户从头到尾编译源码，用户需要的是一个二进制的可执行程序，立刻可以运行。开发者就需要将上一步生成的可执行文件，做成可以分发的安装包。

因此，编译器还必须有生成安装包的功能，常是将可执行文件(连带相关的数据文件)，以某种目录结构，保存成压缩文件包，交给用户。

## 第十一步 动态连接(Dynamic Linking)
正常情况下，程序到这一步已经可以运行了。至于运行期间(runtime)发生的事，一律与编译器无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式。到底是**静态连接(编译时连接)**，还是**动态连接(运行时连接)**。

因此讲解一下**动态连接**:
- 静态连接：把外部函数库，拷贝到可执行文件中。
  - 好处是：适用范围比较广，不用担心用户机器缺少某个库文件;
  - 缺点是：安装包会比较大，而且多个应用程序之间，无法共享文件。

- 动态连接：外部函数库不进入安装包，只有在运行时动态引用。
  - 好处：安装包会比较小，多个应用程序可以共享库文件;
  - 缺点：用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则不能正常运行。

现实中，大多数软件采用动态连接，共享库文件。动态共享的库文件，Linux平台下是后缀为`.so`的文件，win下是`.dll`文件，Mac平台是`.dylib`文件。
