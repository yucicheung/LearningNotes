# 2.3进程间通信
进程间通信(Inter Process Communication,IPC)主要有3个问题：
1. 一个进程如何把信息传递给另一个
2. 确保两个或更多进程在关键活动中不会出现交叉
3. 保持正确的顺序(进程A产生数据，进程B负责打印数据，则B在打印之前必须等待，直到A已经产生一些数据)

线程之间因为共享一个地址空间(不同地址的线程之间通信的问题属于不同进程之间通信)，因此以上后2个问题对于线程来说同样是适应的。因此以下的问题和解决方法也适用于线程。
## 竞争条件
两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为**竞争条件(race condition)**。包含有竞争条件的程序可能在大多测试运行结果都很好，但在极少数情况下会发生无法解释的现象，而多核增长带来的并行使竞争条件越来越普遍。
## 临界区
避免出错的关键是：找出某种途径来阻止多个进程同时读写共享的数据。即，我们需要的是**互斥(mutual exclusion)**(熟悉的mutex锁)，即以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。
解决竞争条件的方案：把对共享内存进行访问的程序片段称为**临界区域(critical region)**或**临界区（critical section）**，如果我们能够合适安排，使**两个进程不能同时处于临界区中**，就能避免竞争条件。

一个好的解决方案，需要同时满足以下4个条件：
1. 任何两个进程不能同时处于其临界区;
2. 不应对CPU的速度和数量做任何假设;
3. 临界区外运行的进程不得阻塞其他进程(除CPU以外的运行条件未具备);
4. 不得使进程无限期等待进入临界区。

![人们期待的进程行为P68]()

## 忙等待的互斥
讨论几种实现互斥的方案，在这些方案中，当一个进程在临界区中更新共享内存时，其他进程将不会进入其临界区，也不会带来任何麻烦。

### 1.屏蔽中断
在单处理器系统中，最简单的方法是使每个进程在刚进入临界区后立即屏蔽所有中断，并且就要离开之前再打开中断，屏蔽中断后，时钟中断也会被屏蔽，而CPU只有发生时钟中断或其他中断时才会进行进程切换。
这样，**在屏蔽中断之后，CPU将不会被切换到其他进程。**于是，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不必担心其他进程介入。

缺点：把屏蔽中断的权利交给用户进程的话，若某个进程屏蔽中断后不再打开中断，整个系统可能会因此终止。并且，如果系统是多处理器(有两个或更多的处理器)，则屏蔽中断仅仅对执行disable指令的CPU有效，其他CPU仍然可以访问共享内存(**即没有避免进程交叉**)。所以，对于内核来说，在更新变量或者列表的几条指令期间将中断屏蔽是方便的，但当就绪进程队列之类的数据状态不一致时发生中断，将导致竞争条件。

结论：屏蔽中断对操作系统本身是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。

### 2.锁变量
设想有一个共享(锁)变量，其初始值为0，当一个进程想进入其临界区时，首先测试这把锁，如果该锁的值为0，则该进程将其设置为1并进入临界区。若这把锁的值为1，则该进程将等待直到其值变为0.

疏漏：假设一个进程读出锁变量的值并发现它为0，而恰好在它将其值设置为1之前，另一个进程被调度运行，则该锁变量设置为1。而前一个进程继续运行时，将锁变量继续设置为1。此时却有两个进程同时进入临界区。(实际上，在用共享变量控制共享区的读写时，如果读、写分成两个操作，在两个时钟下完成，则其中就可能发生在写之前就被其他进程访问的情况)。

### 3.严格轮换法
实际操作系统采用C语言(或偶尔用C++编写)，因为C语言是强大、有效、可预知和有特性的语言。反之，Java就是不可预知的，因为在关键时刻会用完存储器，而在不合适的时候会调用垃圾回收程序回收内存。
