# fork的使用
在Unix和类Unix系统操作系统中，fork是一种创建自身进程副本的操作，它通常是内核实现的一种系统调用。Fork是类UNix操作系统上**创建进程的一种主要方法**。

## 概述
在多任务操作系统中，进程(运行的程序)需要一种方法来创建新进程，如运行其他程序。如果需要启动另一个程序的可执行文件，它需要先fork来创建一个自身的副本，然后由该副本即“子进程”调用exec系统调用，**用其他程序覆盖自身**：停止自己之前的程序并执行其他程序。

Fork操作会为子进程创建一个单独的地址空间，子进程拥有父进程所有内存段的精确副本，根据写时复制(copy-on-write)语义，物理内存不需要被实际复制，取而代之的是，两个进程的虚拟内存页面可能指向物理内存中的同一个页，直到需要写入该页时，写入(复制)才会发生。在用fork配合exec来执行新程序的情况下，这个优化很重要。

当一个进程调用fork时，它被认为是父进程，新创建的进程是它的孩子(子进程)。在fork之后，两个进程还运行着相同的程序，都像是调用了该系统调用(由系统调用程序产生的进程)一般恢复执行。然后它们可以检查调用的返回值确定其状态：是父进程还是紫禁城，及据此行事。

## 通信
子进程从父进程的文件描述符副本开始，对于进程间通信，父进程通常会创建一个或多个管道(将父进程的副本信息传递给子进程)，在fork进程之后，进程关闭它们不需要的管道端。

## fork炸弹
fork bomb是一种利用系统调用fork(或其他等效的方式)进行的阻断服务攻击。fork炸弹会使有进程/程序限制的系统无法开启新的工作阶段，对于不限制进程数的系统则使之停止回应。以fork炸弹为代表的自我复制程序有时被称为wabbit。

### 原理与影响

fork炸弹以极快的速度创建大量进程(进程数以2为底数呈指数级增长)，以此消耗系统分配与进程的可用空间**使进程表饱和**，系统在进程标饱和后就无法运行新进程，除非进程表中的某一进程终止;但是通常fork炸弹程序所创建的所有实例都会不断探测空缺的进程槽并尝试用之创建新进程，因此即使在某进程终止后也不可能运行新进程.

fork炸弹生成的子程序在消耗进程表空间的同时也会占用CPU和内存，从而导致系统与现有进程运行速度放缓，响应时间也会随之大幅增加，从而严重影响系统的正常运作。

在软件开发中有可能会在程序中嵌入fork炸弹，如在用于监听网络套接字并行客户端-服务器结构系统中，服务器端职责的应用程序中可能需要无限循环(loop)与派生(fork)操作，因此在这种情况下，源代码内的细微错误就可能引爆"fork炸弹"。

### fork炸弹实现
- 13个字符(含空格)的shell脚本(指数级增长的fork bomb)
```shell
:(){ :|:& };:
```
上述代码的注解如下：
```
:()		# 定义函数，函数名为":"
{		# 函数起始
	:	# 递归调用":"函数本身
	|	# 管道，将管线输出字元引至
	:	# 再一次调用":"函数，使进程数呈指数级增长
	&	# 进程后台运行，即父进程关闭时子进程仍运行
}		# 函数结束
;		# 分号结束符

:		# 调用`:`函数，引爆fork炸弹
```

- C实现版本
```c
#include<unistd.h>

int main()
{
	while(1)
		fork();
	return 0;
}
```
### 预防fork炸弹
由于fork bomb是通过不断开新进程来瘫痪系统的，一个防止其严重影响系统的方法是限定一个用户能够创建的进程数的上限。在Linux系统下，用`ulimit`命令指定用户可以开启的进程数的max值，或者通过配置文件`/etc/security/limit.conf`来限制可生成的最大进程数来避免炸弹。
