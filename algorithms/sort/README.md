# 排序算法

## 选择排序

选择排序算法:
  - 每次遍历数组找到其中的最小值，添加到一个新数组中，从而形成一个有序排列的新数组。
  - 选择排序时间复杂度为$o(n^2)$。
  - 也是分治法的一种。

## 归并排序

归并排序(Merge Sort)：用归并和分治算法结合排序。
  - 时间复杂度是O(nlogn);
  - 是建立在归并操作上的一种有效排序算法;
  - 是分治法的一种典型应用。
归并(merge)算法：
  - 应用情境：将有序的两个子序列合并，得到完全有序的序列。
  - 递归法(Top-down)：
	1. 申请空间，使其大小为两个有序子序列长度和，该空间用来存放合并后的序列;
	2. 设定2个指针，初始指向2个有序子序列的首位置;
	3. 比较2个指针指向的元素，将更小的元素添加到合并空间，并将指针移动到下一位置;
	4. 重复步骤3,直到指针指向某序列的末尾;
	5. 将另一序列的剩余元素加入合并序列。
  - 迭代法(Bottom-up):假设序列共有n个元素;
	1. 将序列每2个相邻数字进行归并操作，形成ceil(n/2)个序列，每个序列含1或2个数字;
	2. 将每2个相邻序列进行归并操作，形成ceil(n/4)个序列;
	3. 重复步骤2,直到序列数为1,完成归并排序。
归并排序(merge_sort)：将归并算法(merge)和分治算法结合。
  - 递归条件：输入序列的长度大于1;
	- 此时直接返回序列本身;
  - 基线条件：输入序列的长度不大于1;
	- 将序列等分成左序列lseq，右序列rseq，希望对两者进行归并操作;
	- 归并操作前，需要保证两序列有序，因此对两者做merge_sort;
	- 对有序的两序列lseq和rseq做合并(merge)操作并返回。

## 快速排序
快速排序：
  - 是分治法典型应用之一;
  - 平均情况(最佳情况)的运行使劲啊:每次都随机选择一个元素做基准值，*O(log n)\*O(n) = O(nlog n)*；
  - 最糟情况：有序数组的第一个元素作为基准值,*O(n)\*O(n)* = O(n^2),与第一章的大O表示最糟情况不一样，这里的最糟情况不能代表大多数。

快速排序算法：
  - 步骤：
	1. 选择基准值(pivot);
	2. 对数组进行分区(partitioning)，分成大于基准值的元素和小于基准值的元素，及基准值本身；
	3. 对两边的分区进行快速排序。
  - 分治法：
	- 基线条件：数组长度不大于1;
	- 递归条件：数组长度大于1.
