# 函数
- 函数应该怎样才能让读者一看就知道其意图

## 短小
- 函数就应该小，20行封顶最佳

- 代码块和缩进
  - if/else/while语句等，其中的代码块也应该只有一行，该行大抵是一行函数调用语句。好处是既保证语句短小，又能通过函数说明性的名称增加可读性。
  - 由此也说明函数不应该大到能容纳一个嵌套结构。

- 只做一件事
  - 函数应该做一件事。做好一件事。只做一件事。
  - 要判断函数是否只做一件事，就要看是否能再拆分出一个函数。

- 每个函数一个抽象层级
  - 函数中混杂不同抽象层级，往往让人迷惑，读者可能无法判断某个表达式是基础概念还是细节。
  - **自顶向下读代码：向下规则。**让每个函数后面都跟着位于下一抽象层级的函数。这样在查看函数列表时，就可以循抽象层级向下阅读了。这就是向下规则。

- switch语句
  - 保证每个switch语句否埋藏在较低的抽象层级，而且永不重复。**利用多态来实现这点**。(重复是指到处都有类似结构的函数，其中代码重复部分可能很多)。
  - 书中的例子将switch语句埋到抽象工厂底下，不让任何人看到，工厂使用switch语句为Employee的派生物创建恰当的实体(不同的派生类对象)，功能函数(重复性的命名但实际是不同的操作)可以采用Employee(基类)接口多态地接受派遣。

- 使用描述性的名称
  - 给每个方法取具有描述性的名称。
  - 函数越集中、功能越集中，就越便于取一个好名字。
  - 长而具有描述性的名称，要比短而令人费解的名称好，也比描述性的长注释要好。
  - 使用某种命名约定/命名方式要保持一致，使用与模块名一脉相承的短语、名词和动词给函数命名。如`includeSetupPages`,`includeSuiteSetupPages`等。

## 函数参数
- 函数参数
  - **最理想的参数数量是零**(零参数函数)，其次是一(单参数函数)，再次是二(双参数函数)
，应尽量避免三参数函数。(有足够特殊的理由才能用多参数函数，所以无论如何也不要这么做)。
  - **参数不易对付**，它们可能带有太多概念性。由于参数与函数名处在不同的抽象层级，就要求你了解一些目前并不特别重要的细节，从而影响代码的阅读。
  - 从测试角度看，参数越多，要覆盖所有可能值的组合简直令人生畏。
  - 往往返回信息要从函数的返回值输出，如果用输出参数输出可能令人困惑。

- 一元函数的普遍形式
  - 也许是要问询有关于该参数的问题
  - 也许是操作该参数，将其转换为其他什么东西。这种情况下转换结果就该体现为输出值，如果使用输出参数会让人疑惑。
  - 事件(event),在这种形式中，有输入参数而无输出参数，程序将函数看作是一个事件，使用该参数修改系统状态。但应该让读者很清楚了解到这是一个事件。谨慎选用名称和上下文语境。

- 标识参数(指向函数中传入布尔值)
  - 往函数传入布尔值就相当于宣布函数不止做一件事，因为当值为true时这么做，为false时那么做;
  - 正确的方法是将标识值不同时的操作划分为不同函数中

- 二元函数
  - 一个参数的函数比两个参数的函数好懂，如`writeField(name)`比`writeField(outputStream,name)`好懂。
  - 两个参数正好的情况:
	- 两个参数是单个值的有序组成部分，好比`Point(0,0)`;
	- 两个参数之间有自然的顺序。
  - 在不符合上述两点但是有两个参数的函数中，应该尝试传入组合参数、写成对象的方法的形式减少输入参数，转为一元函数。

- 三元参数
  - 三元参数的问题比二元一定更多，因此要谨慎选择

- 参数对象
  - 当函数需要两个、三个或以上的参数时，说明**其中一些参数需要封装为类**了。比如相比于`Circle makeCircle(double x,double y, double radius);`就可以改写成`Circle makeCircle(Point center, double radius);`而变得更为直观;
  - 这里的主要思想是，当一组参数需要被一起传递时，它们往往就是该有自己名称的某个概念。

- 参数列表
  - 当要向一个函数传入数量可变的参数时，就和传递类型为List的单个参数一样没有差别。因此`String.formate`实际是二元函数，声明为`public String format(String format, Object... args)`

- 动词与关键字
  - 对一元函数，函数和参数应该形成一种非常良好的动词、名词形式，如`write(name)`;
  - 也可以把参数的名称编码为函数名，使参数顺序得以明确，如`assertEqual`改为`assertExpectedEqualsActual(expected,actual)`。

## 无副作用
- 无副作用
  - 函数承诺只做一件事(函数名中)，但如果偷偷做其他事情(即副作用)，如修改全局变量等，就可能会导致古怪的时序性耦合及顺序依赖。

- 输出参数(用来输出的参数)
  - 参数多数会被自然而然地看作是函数的输入，如果传递的参数不用来输入而用来输出，则会导致疑惑;
  - 庆幸的是，在面向对象编程出现之后，因为`this`也有输出参数的意味在内，因此可以调用对象的方法进行参数的传出。比如相比调用`public void appendFooter(StringBuffer report)`我们调用对象的`report.appendfooter()`会好很多。**如果非要改变状态，就改变对象的状态。**

## 分割指令与询问
- 函数一般1.要么做什么事2.要么回答什么事，二者不可兼得(因此函数可以只做一件事)。  - 做什么事，修改某对象的状态
  - 回答什么事，返回对象的有关信息

- 如果函数中出现两种工作混合在一起，则解决方案是将两者分割开来，作为不同函数再一起协调工作。
```
if (attributeExists("username")) {
	setAttibute("username","unclebob");
}
```

## 使用异常替代返回错误码
- 从指令式函数返回错误码鼓励了在if语句中把指令当作表达式用，结果是**引起更深层次的嵌套结构**。因为在代码行出现错误码时总是要求立即对错误码进行处理。但**使用异常替代错误码，就能使错误处理代码从主路径代码中分离出来。**

- 抽离Try/Catch代码块
  - 最好把try/catch代码块的主体部分抽离出来，另外形成函数;

- 错误处理就是一件事
  - 一个函数只干好一件事，因此当函数用于错误处理时，就专注于错误处理这件事。例如，当try在某个函数中存在，它就该是这个函数中的第一个单词，catch/finally后也应该只做这件事。

- Error.java依赖磁铁
  - 错误码意味着某处有个类或者是枚举定义了这些错误码，这个类就是一块依赖磁铁，其他很多类都要导入和使用它。
  - 坏处是，当该枚举/类修改时，所有其他引用它的类都需要重新编译和部署，这对Error类造成了负面影响。(**我们应当减少依赖关系**)
  - 而如果使用异常，从异常基类中派生出一个新的异常是更容易的事。 

## DRY(Don't Repeat Yourself)
- 代码的重复问题
  - 代码重复会使代码显得臃肿，也会使得修改不方便;选择用基类派生的方式可以解决很多重复问题(面向对象有利于消除重复)。
  - 重复可能是软件中一切邪恶的根源，许多原则和实践规则都是为**控制与消除重复**而创建的。

## 结构化编程
- 规则包括(未必正确)
  - 每个函数中只有一个return
  - 循环中不能有break或continue
  - 永远不能有goto语句

- 但是
  - 只要保持函数短小，偶尔出现return、break、continue没有坏处，甚至比单入单出更有表达力
  - goto一般只在大函数中才有必要，小函数中确实要避免

## 如何写出这样的代码
- 写代码和写论文一样，先写初稿，再打磨
  - 分解函数
  - 修改名称
  - 消除重复
  - 缩短和重新安置方法
  - ...

- **不要从一开始就想写出完美的函数。**

## 总结
- 函数是语言的动词，类是名词，他们共同构成编程语言的艺术。
- 把系统当作故事来讲(跪拜)。
